//after an entire rotation, (8 SLL) then we store the next one
//R2 holds the current byte to check, then we rotate left whenever we add something new to the current iteration
//R0 holds the pattern
//R3 holds current iteration
//R4 removes last 3 bits

AND R3 0 
ADD R3 R1 
SLL R3 5 //00100000
LW R3 0 //pattern
AND R0 0 
ADD R0 R2 

//load byte 0 into R3 
AND R3 0
LW R3 0 
ADD R3 R2 

//load next mem location byte
AND R4 0
LW R4 1
AND R4 0 

ADD R4 R3 //R4 = R4 = b1 b2 b3 b4 b5 b6 b7 b8
ADD R5 R4 //R5 = b1 b2 b3 b4 b5 b6 b7 b8
AND R5 7 //R5 = 0 0 0 0 0 b6 b7 b8 
XOR R4 R5 //R4 =  b1 b2 b3 b4 b5 0 0 0 //check R4 with pattern

SLL R3 1 //b2 b3 b4 b5 b6 b7 b8 b1
AND R4 0 
ADD R4 R3 
AND R4 1 //0 0 0 0 0 0 0 b1
XOR R3 R4 //b2 b3 b4 b5 b6 b7 b8 0 

SLL R2 1 //b10 b11 b12 b13 b14 b15 b16 b9
AND R4 0 
ADD R4 R2 //b10 b11 b12 b13 b14 b15 b16 b9
AND R4 1 //0 0 0 0 0 0 0 b9

ADD R3 R4 ///b2 b3 b4 b5 b6 b7 b8 b9
